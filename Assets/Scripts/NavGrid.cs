/*
* NavGrid.cs
* By: William McCarty
* A* Pathfinding Logic
* */
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

public class NavGrid : MonoBehaviour
{
    private const float DefaultXSize = 50f;
    private const float DefaultYSize = 50f;
    private const float DefaultNodeSize = 5f;
    private const int DefaultXNodes = 10;
    private const int DefaultYNodes = 10;
    
    /// <summary>
    /// Size of the Grid for all NavGridPathNode Coords
    /// </summary>
    [SerializeField]
    private Vector2 _gridSize = new Vector2(DefaultXSize,DefaultYSize);
    /// <summary>
    /// Size across a Node will be in both X and Z axis
    /// </summary>
    [SerializeField]
    private float _nodeSize = DefaultNodeSize;
    /// <summary>
    /// NavGridPathNodes inside the Grid
    /// </summary>
    [SerializeField]
    private NavGridPathNode[,] _navGridPathNodes;
    /// <summary>
    /// Mask we are not wanting to allow walking on/thru
    /// </summary>
    [SerializeField]
    private LayerMask _blockedMask;
    /// <summary>
    /// Sets how many Nodes across the X Grid we will allow
    /// </summary>
    private int _xNodes = DefaultXNodes;
    /// <summary>
    /// Sets how many Nodes across the Y Grid we will allow
    /// </summary>
    private int _yNodes = DefaultYNodes;
    
    /// <summary>
    /// Turns on Player path in editor
    /// </summary>
    [Space(10)]
    [Header("Debug")]
    [SerializeField]
    private bool _debug;
    /// <summary>
    /// Shows NavGridPathNode Coord in editor
    /// </summary>
    [SerializeField]
    private bool _showCoords;
    /// <summary>
    /// Fills NavGridPathNode with path state 
    /// </summary>
    [SerializeField]
    private bool _showNavGridNodesAsCubes;
    /// <summary>
    /// Marks NavGridPathNode with wire cube with path state 
    /// </summary>
    [SerializeField]
    private bool _showNavGridNodesAsWired;
    
    /// <summary>
    /// Starting NavGridPathNode Coord for pathfinding to start at
    /// </summary>
    private Vector2 _startCoord;
    /// <summary>
    /// End NavGridPathNode Coord for pathfinding to end at
    /// </summary>
    private Vector2 _endCoord;
    /// <summary>
    /// NavGridPathNode that have been discovered and can be processed
    /// </summary>
    private List<NavGridPathNode> _openNodes = new List<NavGridPathNode>();
    /// <summary>
    /// NavGridPathNode that have been processed
    /// </summary>
    private List<NavGridPathNode> _closedNodes = new List<NavGridPathNode>();
    /// <summary>
    /// Final path generated by pathfinding logic
    /// </summary>
    private List<NavGridPathNode> _pathNodes = new List<NavGridPathNode>();

    private float _initializedNodeSize;
    
    
    /// <summary>
    /// Given the current and desired location, return a path to the destination
    /// </summary>
    /// <param name="origin">Starting point for pathfinding.</param>
    /// <param name="destination">Ending point for pathfinding.</param>
    public NavGridPathNode[] GetPath(Vector3 origin, Vector3 destination)
    {
        //Clears Previous Data
        _openNodes.Clear();
        _closedNodes.Clear();
        if (_navGridPathNodes == null)
        {
            //If we haven't constructed the NavGridPathNodes then initialize them
            ConstructNavGridPathNodes();
            _initializedNodeSize = _nodeSize;
        }
        //we do this to prevent changes after the construction of the nav is completed
        _nodeSize = _initializedNodeSize;
        //Reinitialize NavGridPathNode Data for new pathfinding call
        ResetNavGridPathNodes();
        SetStartNavGridPathNode(origin);
        SetDestinationNavGridPathNode(destination);
        SetBlockedNavGridPathNodes();

        //Add the starting node
        _openNodes.Add(GetNavGridPathNode(_startCoord));
        
        //Keep looping till no more openNodes
        while (_openNodes.Count > 0)
        {
            //Sort by lowest cost, so we always get the closest node
            NavGridPathNode node = _openNodes.OrderBy(o => o.TotalCost).First();
            if (node.Type == NavGridPathNode.NodeType.End)
            {
                //If this is the End Node were done
                break;
            }
            _openNodes.Remove(node);
            _closedNodes.Add(node);

            //Start updating costs of all surrounding Nodes
            int xCoord = node.GetXCoord();
            int yCoord = node.GetYCoord();
            int minX = xCoord - 1;
            int minY = yCoord - 1;
            int maxX = xCoord + 1;
            int maxY = yCoord + 1;
            //Bot Right
            UpdateCost(minX, maxY, _openNodes, _closedNodes, node);
            //Mid Right
            UpdateCost(xCoord, maxY, _openNodes, _closedNodes, node);
            //Top Right
            UpdateCost(maxX, maxY, _openNodes, _closedNodes, node);
            //Bot Mid
            UpdateCost(minX, yCoord, _openNodes, _closedNodes, node);
            //Top Mid
            UpdateCost(maxX, yCoord, _openNodes, _closedNodes, node);
            //Top Left
            UpdateCost(minX, minY, _openNodes, _closedNodes, node);
            //Mid Left
            UpdateCost(xCoord, minY, _openNodes, _closedNodes, node);
            //Top Left
            UpdateCost(maxX, minY, _openNodes, _closedNodes, node);
        }

        //Follow the parents to return back to the start node and construct the path
        _pathNodes.Clear();
        NavGridPathNode pathNode = GetNavGridPathNode(_endCoord);
        while (pathNode.ParentCoord.x >= 0 && pathNode.ParentCoord.x < _xNodes
                                           && pathNode.ParentCoord.y >= 0 && pathNode.ParentCoord.y < _yNodes)
        {
            _pathNodes.Add(pathNode);
            pathNode = GetNavGridPathNode(pathNode.ParentCoord);
        }
        _pathNodes.Add(pathNode);

        //The order has the end Node first, so to successfully have the path we need to flip it
        _pathNodes.Reverse();

        return _pathNodes.ToArray();
    }

    /// <summary>
    /// Updates the cost of the NavGridPathNode that the coord
    /// </summary>
    /// <param name="x">X coord of the NavGridPathNode having cost updated.</param>
    /// <param name="y">Y coord of the NavGridPathNode having cost updated.</param>
    /// <param name="openNodes">Current Open List.</param>
    /// <param name="closedNodes">Current Closed List.</param>
    /// <param name="parentNode">The NavGridPathNode that has discovered this Node.</param>
    private void UpdateCost(int x, int y, List<NavGridPathNode> openNodes, List<NavGridPathNode> closedNodes, NavGridPathNode parentNode)
    {
        //Assure the x and y is within our GridNode range
        if (x >= 0 && x < _xNodes && y >= 0 && y < _yNodes)
        {
            //get the node at the coord
            NavGridPathNode node = GetNavGridPathNode(new Vector2(x, y));
            //Only process if not Blocked and not in Closed List
            if (node.Type != NavGridPathNode.NodeType.Blocked && !closedNodes.Any(obj => obj.GetXCoord() == x && obj.GetYCoord() == y))
            {
                if (!openNodes.Any(obj => obj.GetXCoord() == x && obj.GetYCoord() == y))
                {
                    //This is a new NavGridPathNode and hasn't been discovered
                    
                    //Update parent and update the struct ref
                    node.ParentCoord = parentNode.Coord;
                    UpdateNavGridPathNode(node);
                    
                    //Calculate H of A* cost formula
                    double hA = Math.Pow(Mathf.Abs(_endCoord.x - node.GetXCoord()), 2f);
                    double hB = Math.Pow(Mathf.Abs(_endCoord.y - node.GetYCoord()), 2f);
                    int h = Convert.ToInt32(hA + hB);
                    
                    //Back tracking steps to get G cost of A* cost formula
                    int g = GetDistToStartFromNode(node, node.ParentCoord);

                    //Combine to get total cost and update struct ref
                    node.TotalCost = g + h;
                    node.DistToStart = g;
                    node.Heuristic = h;
                    UpdateNavGridPathNode(node);
                    
                    //Add to open list
                    openNodes.Add(node);
                }
                else 
                {
                    //The NavGridPathNode has already been discovered
                    
                    
                    //Calculate G using the current parent 
                    int currentG = GetDistToStartFromNode(node, node.ParentCoord);
                    //Calculate G using the new node that discovered it as the parent
                    int adjustedG = GetDistToStartFromNode(node, parentNode.Coord);
                    
                    //If the new node has a lower cost then we update the parent to this node
                    if (adjustedG < currentG)
                    {
                        double hA = Math.Pow(Mathf.Abs(_endCoord.x - node.GetXCoord()), 2f);
                        double hB = Math.Pow(Mathf.Abs(_endCoord.y - node.GetYCoord()), 2f);
                        int h = Convert.ToInt32(hA + hB);

                        //Update parent and cost then update the struct ref
                        node.ParentCoord = parentNode.Coord;
                        node.DistToStart = adjustedG;
                        node.TotalCost = adjustedG + h;
                        UpdateNavGridPathNode(node);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Calculates Distance from the current NavGridPathNode by traversing back from its parent to the start
    /// </summary>
    /// <param name="node">Starting NavGridPathNode to traverse from.</param>
    /// <param name="parentCoord">Parent coord to begin traversing back from.</param>
    /// <returns>G cost from the current NavGridPathNode traversing back from parent coord.</returns>
    private int GetDistToStartFromNode(NavGridPathNode node, Vector2 parentCoord)
    {
        int startX = Convert.ToInt32(_startCoord.x);
        int startY = Convert.ToInt32(_startCoord.y);
        
        NavGridPathNode curNode = node;
        int curX = curNode.GetXCoord();
        int curY = curNode.GetYCoord();
        Vector2 curParentCoord = parentCoord;
        //Back tracking steps till we reach the start Coord
        int g = 0;
        while (curX != startX && curY != startY)
        {
            //Move to parent NavGridPathNode and increment G cost
            NavGridPathNode prevNode = GetNavGridPathNode(curParentCoord);
            curX = prevNode.GetXCoord();
            curY = prevNode.GetYCoord();
            curNode = prevNode;
            curParentCoord = curNode.ParentCoord;
            g++;
        }
        
        return g;
    }
    
    /// <summary>
    /// Gets NavGridPathNode at the coord
    /// </summary>
    /// <param name="coord">Coord to get NavGridPathNode Struct.</param>
    /// <returns>NavGridPathNode at the coord.</returns>
    private NavGridPathNode GetNavGridPathNode(Vector2 coord)
    {
        //If the node is out of range throw an exception
        if (coord.x >= _xNodes || coord.y >= _yNodes)
        {
            Debug.LogError("Invalid Coordinate to get Node");
            throw new Exception("Invalid Coordinate to get Node");
        }
        
        return _navGridPathNodes[Convert.ToInt32(coord.x), Convert.ToInt32(coord.y)];
    }
    
    /// <summary>
    /// Initializes Starting position based on the world point
    /// </summary>
    /// <param name="originPoint">Starting point in world space.</param>
    private void SetStartNavGridPathNode(Vector3 originPoint)
    {
        //Convert world space to our NavGrid space coord
        Vector2 startCoord = FindNavGridPathNode(originPoint);
        //Change type of this NavGridPathNode to the Start type
        _navGridPathNodes[Convert.ToInt32(startCoord.x), Convert.ToInt32(startCoord.y)].Type = NavGridPathNode.NodeType.Start;
        _startCoord = startCoord;
    }
    
    /// <summary>
    /// Initializes Destination position based on the world point
    /// </summary>
    /// <param name="destinationPoint">Destination point in world space.</param>
    private void SetDestinationNavGridPathNode(Vector3 destinationPoint)
    {
        //Assure that destination is a valid walkable NavGridPathNode
        bool isWalkable = !Physics.CheckBox(destinationPoint, new Vector3(_nodeSize/2, _nodeSize/2, _nodeSize/2), Quaternion.identity,
            _blockedMask);
        if (isWalkable)
        {
            //Convert world space to our NavGrid space coord
            Vector2 endCoord = FindNavGridPathNode(destinationPoint);
            //Change type of this NavGridPathNode to the End type
            _navGridPathNodes[Convert.ToInt32(endCoord.x), Convert.ToInt32(endCoord.y)].Type = NavGridPathNode.NodeType.End;
            _endCoord = endCoord;
        }

    }
    
    /// <summary>
    /// Sets all NavGridPathNodes that are in a blocked location
    /// </summary>
    private void SetBlockedNavGridPathNodes()
    {
        for (var x = 0; x < _xNodes; x++)
        {
            for (var y = 0; y < _yNodes; y++)
            {
                //Assure this not is not start/end
                if (_navGridPathNodes[x, y].Type != NavGridPathNode.NodeType.End
                    && _navGridPathNodes[x, y].Type != NavGridPathNode.NodeType.Start)
                {
                    //If its not walkable then we set it to blocked otherwise it is walkable
                    bool isWalkable = !Physics.CheckBox(_navGridPathNodes[x, y].Position, new Vector3(_nodeSize/2, _nodeSize/2, _nodeSize/2), Quaternion.identity,
                        _blockedMask);
                    _navGridPathNodes[x, y].Type = isWalkable ? NavGridPathNode.NodeType.Walkable : NavGridPathNode.NodeType.Blocked; 
                }
               
            }
        }
    }
    
    /// <summary>
    /// Gets NavGridPathNode coord from world space coord
    /// </summary>
    /// <param name="originPoint">World space point to find NavGridPathNode coord.</param>
    /// <returns>Vector2 coord of NavGridPathNode of point.</returns>
    private Vector2 FindNavGridPathNode(Vector3 originPoint)
    {
        if (originPoint.x > _gridSize.x / 2f || originPoint.x < -_gridSize.x / 2f)
        {
            Debug.LogError("Point is off grid in X Coord");
            return Vector2.zero;
        }
        if (originPoint.z > _gridSize.y / 2f || originPoint.z < -_gridSize.y / 2f)
        {
            Debug.LogError("Point is off grid in Z Coord");
            return Vector2.zero;
        }
        
        int minXIndex = 0;
        //is 0 base so -1 to make sure its a valid index
        int maxXIndex = _xNodes - 1 ;
        int curXIndex = Convert.ToInt32(maxXIndex / 2);
        
        //coord flipped to reflect correct 2d array mapping
        //get mid point min and max
        float minNodeXCoord = _navGridPathNodes[0, curXIndex].Position.x - _nodeSize / 2;
        float maxNodeXCoord = _navGridPathNodes[0, curXIndex].Position.x + _nodeSize / 2;
        
        //perform binary search
        //keep looping until the point is within the limits of the min and max
        while (maxNodeXCoord < originPoint.x || minNodeXCoord > originPoint.x)
        {
            if (maxNodeXCoord < originPoint.x)
            {
                //point is beyond max so we need to change min to be the cur mid
                minXIndex = curXIndex;
                //mid moves to the mid of the right end
                curXIndex =  Mathf.Clamp(minXIndex +  Mathf.CeilToInt((maxXIndex - minXIndex) / 2f), 0, _xNodes - 1);
            }
            else
            {
                //point is lower than max so we change max to be the cur mid
                maxXIndex = curXIndex;
                //mid moves to the mid of the left
                curXIndex =  Mathf.Clamp(minXIndex -  Mathf.FloorToInt((maxXIndex - minXIndex) / 2f), 0, _xNodes - 1);
            }
            
            //get nex min and max points in world space
            minNodeXCoord = _navGridPathNodes[0, curXIndex].Position.x - _nodeSize / 2;
            maxNodeXCoord = _navGridPathNodes[0, curXIndex].Position.x + _nodeSize / 2;
        }
        
        int minYIndex = 0;
        //is 0 base so -1 to make sure its a valid index
        int maxYIndex = _yNodes - 1;
        int curYIndex = Convert.ToInt32(maxYIndex / 2);

        //coord flipped to reflect correct 2d array mapping
        //get mid point min and max
        float minNodeYCoord = _navGridPathNodes[curYIndex, 0].Position.z - _nodeSize / 2;
        float maxNodeYCoord = _navGridPathNodes[curYIndex, 0].Position.z + _nodeSize / 2;
        
        //perform binary search
        //keep looping until the point is within the limits of the min and max
        while ( maxNodeYCoord < originPoint.z || minNodeYCoord > originPoint.z)
        {
            if (maxNodeYCoord < originPoint.z)
            { 
                //point is beyond max so we need to change min to be the cur mid
                minYIndex = curYIndex;
                //mid moves to the mid of the right end
                curYIndex =  Mathf.Clamp(minYIndex + Mathf.CeilToInt((maxYIndex - minYIndex) / 2f), 0, _yNodes - 1);
            }
            else
            {
                //point is lower than max so we change max to be the cur mid
                maxYIndex = curYIndex;
                //mid moves to the mid of the left
                curYIndex =  Mathf.Clamp(minYIndex -  Mathf.FloorToInt((maxYIndex - minYIndex) / 2f), 0, _yNodes - 1);
            }
            //get nex min and max points in world space
            minNodeYCoord = _navGridPathNodes[curYIndex, 0].Position.z - _nodeSize / 2;
            maxNodeYCoord = _navGridPathNodes[curYIndex, 0].Position.z + _nodeSize / 2;
        }
        
        //Coord of NavGridPathNode
        return new Vector2(curYIndex, curXIndex);

    }

    /// <summary>
    /// Resets all NavGridPathNodes
    /// </summary>
    private void ResetNavGridPathNodes()
    {
        for (var x = 0; x < _xNodes; x++)
        {
            for (var y = 0; y < _yNodes; y++)
            {
                _navGridPathNodes[x, y].Reset();
            }
        }
    }

    /// <summary>
    /// Initializes NavGridPathNodes in the NavGrid
    /// </summary>
    private void ConstructNavGridPathNodes()
    {
        //Created initial 2D Array
        _xNodes = Convert.ToInt32(Mathf.Floor(_gridSize.x / _nodeSize));
        _yNodes = Convert.ToInt32(Mathf.Floor(_gridSize.y / _nodeSize));
        _navGridPathNodes = new NavGridPathNode[_xNodes, _yNodes];
        
        float halfNodeSize = _nodeSize / 2;
        //We - the halfNode so it can be uniform in the loop and just use the entire nodeSize
        var position = this.transform.position;
        //Offset by the gridsize
        float curX = position.x + -Convert.ToInt32(_gridSize.x / 2) - halfNodeSize;
        float curY = position.z + -Convert.ToInt32(_gridSize.y / 2) - halfNodeSize;
        for (var x = 0; x < _xNodes; x++)
        {
            //store for the next iteration to use
            float startingX = curX;
            for (var y = 0; y < _yNodes; y++)
            {
                Vector3 center = new Vector3(curX + _nodeSize , 0, curY + _nodeSize);
                NavGridPathNode node = new NavGridPathNode(center, new Vector2(x, y));
                _navGridPathNodes[x, y] = node;
                //Set x to start at this center for when it calculates next center
                curX = center.x;
            }

            //resets the curX to the start of the X row again
            curX = startingX;
            //moves to next y
            curY += _nodeSize;
        }
        
        
    }
    
    /// <summary>
    /// Updates reference of NavGridPathNode so it reflects in the 2d struct array
    /// </summary>
    /// <param name="navGridPathNode">Struct object to replace reference in 2d array.</param>
    private void UpdateNavGridPathNode(NavGridPathNode navGridPathNode)
    {
        //Used to update the ref
        _navGridPathNodes[navGridPathNode.GetXCoord(), navGridPathNode.GetYCoord()] = navGridPathNode;
    }
    
    #if UNITY_EDITOR
    /// <summary>
    /// Draws editor gize to visualize pathfinding
    /// </summary>
    private void OnDrawGizmos()
    {
        //We only want to do this if we are in debug mode
        if (!_debug || _nodeSize == 0) return;
        
        //Draw grid
        Gizmos.color = Color.white;
        var position = this.transform.position;
        Gizmos.DrawWireCube(position, new Vector3(_gridSize.x, .1f, _gridSize.y));
        
        
        float halfNodeSize = _nodeSize / 2;
        int xNodes = Convert.ToInt32(Mathf.Floor(_gridSize.x / _nodeSize));
        int yNodes = Convert.ToInt32(Mathf.Floor(_gridSize.y / _nodeSize));
        
        //We - the halfNode so it can be uniform in the loop and just use the entire nodeSize
        float curX = position.x + -Convert.ToInt32(_gridSize.x / 2) - halfNodeSize;
        float curY = position.z + -Convert.ToInt32(_gridSize.y / 2) - halfNodeSize;
        
        //loop through NavGrid
        for (var x = 0; x < xNodes; x++)
        {
            float startingX = curX;
            for (var y = 0; y < yNodes; y++)
            {
                //Change color of NavGridPathNode based on state its in
                if (_openNodes.Any(obj => obj.GetXCoord() == x && obj.GetYCoord() == y))
                {
                    Gizmos.color = Color.green;
                }
                else if (_closedNodes.Any(obj => obj.GetXCoord() == x && obj.GetYCoord() == y))
                {
                    Gizmos.color = Color.magenta;
                }
                else if (_navGridPathNodes != null && _navGridPathNodes.GetLength(0) > 0 && _navGridPathNodes.GetLength(1) > 0 
                         && _navGridPathNodes[x, y].Type == NavGridPathNode.NodeType.Blocked)
                {
                    Gizmos.color = Color.black;
                }
                else
                {
                    Gizmos.color = Color.white;
                }
                
                //This is the path the player will follow
                if (_pathNodes.Any(obj => obj.GetXCoord() == x && obj.GetYCoord() == y))
                {
                    Gizmos.color = Color.cyan;
                }
                if (y == Convert.ToInt32(_startCoord.y) && x == Convert.ToInt32(_startCoord.x))
                {
                    Gizmos.color = Color.blue;
                }
                else if (y == Convert.ToInt32(_endCoord.y) && x == Convert.ToInt32(_endCoord.x))
                {
                    Gizmos.color = Color.red;
                }
                Vector3 center = new Vector3(curX + _nodeSize , 0, curY + _nodeSize);

                //Show NavGridPathNode as filled in so its clearer to see the state
                if (_showNavGridNodesAsCubes)
                {
                    Gizmos.DrawCube(center, new Vector3(_nodeSize, .1f, _nodeSize));
                }
                //Show as Wired to get a minor view of the state of the path
                else if (_showNavGridNodesAsWired)
                {
                    Gizmos.DrawWireCube(center, new Vector3(_nodeSize, .1f, _nodeSize));
                }

                //Show NavGrid Coord of the node
                if (_showCoords)
                {
                    GUIStyle style = new GUIStyle(GUI.skin.label);
                    style.normal.textColor = Color.black;
                    Gizmos.color = Color.black;
                    Handles.Label(center, "(" + x + ", " + y + ")", new GUIStyle()
                    {
                        normal = { textColor = Color.black }
                    }); 
                }
                //Set x to start at this center for when it calculates next center
                curX = center.x;
            }

            //resets the curX to the start of the X row again
            curX = startingX;
            //moves to next y
            curY += _nodeSize;
        }
    }
    #endif
}
